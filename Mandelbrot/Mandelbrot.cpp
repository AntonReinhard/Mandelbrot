#include "Mandelbrot.h"
#include "helpers.h"

#include <iostream>
#include <chrono>
#include <iomanip>
#include <thread>
#include <unistd.h>

int main() {
	const auto start = std::chrono::steady_clock::now();

	read_colors();

	const auto resolution = get_option("What resolution do you want to render in",
									   { "16k", "8k", "4k", "FullHD" });

	mandelbrot_init();

	uint32_t image_width = 1920;
	uint32_t image_height = 1080;

	switch(resolution)
	{
	case 1:	//16k
		image_width = 15360;
		image_height = 8640;
		break;

	case 2: //8k
		image_width = 7680;
		image_height = 4320;
		break;

	case 3:	//4k
		image_width = 3840;
		image_height = 2160;
		break;

	case 4:	//FullHD
		image_width = 1920;
		image_height = 1080;
		break;

	default:
		break;
	}

	const auto filepath = get_string("What filepath should the images be written to");

	const auto zoom_factor = get_double("What zoom factor do you want");

	const auto im_num = get_number("How many frames");

	const uint32_t max_threads = get_number("How many threads");

	const uint32_t precision = get_number("How many bits precision");

	mpf_class zoom = 4;
	zoom.set_prec(precision);

	const std::string zoom_x_str = "-1.7693831791955150182138472860854737829057472636547514374655282165278881912647564588361634463895296673044858257818203031574874912384217194031282461951137475212550848062085787454772803303225167998662391124184542743017129214423639793169296754394181656831301342622793541423768572435783910849972056869527305207508191441734781061794290699753174911133714351734166117456520272756159178932042908932465102671790878414664628213755990650460738372283470777870306458882898202604001744348908388844962887074505853707095832039410323454920540534378406083202543002080240776000604510883136400112955848408048692373051275999457470473671317598770623174665886582323619043055508383245744667325990917947929662025877792679499645660786033978548337553694613673529685268652251959453874971983533677423356377699336623705491817104771909424891461757868378026419765129606526769522898056684520572284028039883286225342392455089357242793475261134567912757009627599451744942893765395578578179137375672787942139328379364197492987307203001409779081030965660422490200242892023288520510396495370720268688377880981691988243756770625044756604957687314689241825216171368155083773536285069411856763404065046728379696513318216144607821920824027797857625921782413101273331959639628043420017995090636222818019324038366814798438238540927811909247543259203596399903790614916969910733455656494065224399357601105072841234072044886928478250600986666987837467585182504661923879353345164721140166670708133939341595205900643816399988710049682525423837465035288755437535332464750001934325685009025423642056347757530380946799290663403877442547063918905505118152350633031870270153292586262005851702999524577716844595335385805548908126325397736860678083754587744508953038826602270140731059161305854135393230132058326419325267890909463907657787245924319849651660028931472549400310808097453589135197164989941931054546261747594558823583006437970585216728326439804654662779987947232731036794099604937358361568561860539962449610052967074013449293876425609214167615079422980743121960127425155223407999875999884";
	const std::string zoom_y_str = "0.00423684791873677221492650717136799707668267091740375727945943565011234400080554515730243099502363650631353268335965257182300494805538736306127524814939292355930892834392050796724887904921986666045576626946900666103494014904714323725586979789908520656683202658064024115300378826789786394641622035341055102900456305723718684527210377325846307917512628774672005693326232806953822796755832517188873479124361430989485495501124096329421682827330693532171505367455526637382706988583456915684673202462211937384523487065290004627037270912806345336469007546411109669407622004367957958476890043040953462048335322273359167297049252960438077167010004209439515213189081508634843224000870136889065895088138204552309352430462782158649681507477960551795646930149740918234645225076516652086716320503880420325704104486903747569874284714830068830518642293591138468762031036739665945023607640585036218668993884533558262144356760232561099772965480869237201581493393664645179292489229735815054564819560512372223360478737722905493126886183195223860999679112529868068569066269441982065315045621648665342365985555395338571505660132833205426100878993922388367450899066133115360740011553934369094891871075717765803345451791394082587084902236263067329239601457074910340800624575627557843183429032397590197231701822237810014080715216554518295907984283453243435079846068568753674073705720148851912173075170531293303461334037951893251390031841730968751744420455098473808572196768667200405919237414872570568499964117282073597147065847005207507464373602310697663458722994227826891841411512573589860255142210602837087031792012000966856067648730369466249241454455795058209627003734747970517231654418272974375968391462696901395430614200747446035851467531667672250261488790789606038203516466311672579186528473826173569678887596534006782882871835938615860588356076208162301201143845805878804278970005959539875585918686455482194364808816650829446335905975254727342258614604501418057192598810476108766922935775177687770187001388743012888530139038318783958771247007926690";
	mpf_class zoom_x;
	mpf_class zoom_y;
	zoom_x.set_prec(precision);
	zoom_y.set_prec(precision);
	zoom_x.set_str(zoom_x_str, 10);
	zoom_y.set_str(zoom_y_str, 10);

	std::cout << "Using " << zoom.get_prec() << " bits precision" << std::endl;

	for (uint32_t i = 1; i <= im_num; ++i) {
		
		while (thread_counter >= max_threads) {
			usleep(50000);
		}
		
		++thread_counter;

		std::stringstream filename;
		filename << filepath << "/frame" << std::setfill('0') << std::setw(5) << i << ".bmp";

		//std::cout << "Zoom_x:" << zoom_x << "\nZoom_y: " << zoom_y << "\nZoom: " << zoom << std::endl;

		std::thread t(write_frame, zoom_x, zoom_y, zoom, filename.str(), image_width, image_height);
		t.detach();

		zoom *= zoom_factor;
		std::cout << "\rFrame: " << i << std::flush;
	}

	//wait for remaining threads
	while (thread_counter > 0) {
		usleep(50000);
	}
	
	const auto end = std::chrono::steady_clock::now();
	const auto diff = end - start;
	const auto sec = std::chrono::duration_cast<std::chrono::seconds>(diff).count();
	const auto msec = std::chrono::duration_cast<std::chrono::milliseconds>(diff).count();

	std::cout << "\nTook: " << sec << "." << msec << "s" << std::endl;

	return 0;
}

//115 sec
//112 nach arithmetik
//5 sec release x64
//3.39 sec
//603 sec with 65535 N_MAX
//422 sec for 25000x22000 with N_MAX = 100
